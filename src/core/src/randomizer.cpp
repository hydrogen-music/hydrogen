/*
 * Hydrogen
 * Copyright(c) 2002-2008 by Alex >Comix< Cominu [comix@users.sourceforge.net]
 * Humanizer
 * Copyright(c) 2018 by Philipp MÃ¼ller [thegreatwhiteshark@googlemail.com]
 *
 * http://www.hydrogen-music.org
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY, without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 */

#include <hydrogen/randomizer.h>
#include <cstdlib>

namespace H2Core {

Randomizer* Randomizer::__instance = 0;

/**
 * @brief Constructor initializing the states of the individual
 * colors.
 *
 * Since the \p uniform_white() function is used within the generation
 * of all other colors the state of the uniform white noise generator
 * is initialized first. This is done using a random seed drawn by the
 * \p std::rand() function. The output of the \p std::rand() function
 * will be of type integer and the first bits will be filled with
 * zeros in the conversion into a 64 bit integer. But since this only
 * affects the initialization step, it won't cause any problems within
 * for the algorithms within used within the Randomizer.
 *
 * @return Object of class Randomizer.
 */
Randomizer::Randomizer() :
	uniformStateInt64( 4101842887655102017LL ) {
	__instance = this;
	//
	// Random seed used to initiate the Randomizer object. 
	// 
	// The output of the std::rand() function will be of type
	// integer and the first bits will be filled with zeros in the
	// conversion into a 64 bit integer. But since this only
	// affects the initialization step, it won't cause any
	// problems within for the algorithms within used within the
	// Randomizer.
	//
	unsigned long long int initialSeed = std::rand();
	//
	// Initialize the white uniform noise source.
	uniformStateInt64 ^= initialSeed;
	uniformStateInt64 = white_uniform_int64();
	//
	// Initialize the Gaussian white noise source.
	gaussianSecondVariable = 0.;
	//
	// Initialize the pink noise source.
	indexPink = 0;
	// Mask specifying the biggest number allowed for the index.
	indexMaskPink = ( 1 << PINK_USED_ROWS ) - 1;
	// Biggest possible signed random value generated by the pink
	// noise generator. An extra 1 is added for the white noise
	// source added to the pink noise.
	maxValuePink = ( PINK_USED_ROWS + 1 ) *
		( 1 << ( PINK_BITS - 1 ) );
	// Normalization constant to convert the output into float.
	normalizationPink = 1.0f/ maxValuePink;
	// Initialize the different rows containing the independent
	// white noise sources. 
	for( int ii = 0; ii < PINK_USED_ROWS; ii++ ){
		rowsPink[ ii ] = 0;
	}
	// This variable will contain the sum over all independent
	// white noises.
	runningSumPink = 0;
}

/**
 * Create an instance within Hydrogen
 */
Randomizer* Randomizer::create_instance(){
	if ( __instance == 0 ){
		__instance = new Randomizer;
	}
	return __instance;
}
/**
 * Retrieve the created instance
 */
Randomizer* Randomizer::get_instance(){
	assert( __instance );
	return __instance;
}
/////////////////////// White uniform noise //////////////////////////
/**
 * @brief Uniform white noise generator for 64 bit integers.
 *
 * A Composed generator with a multiplicative linear congruential
 * generator as the outer method and a 64-bit Xorshift method as the
 * inner one.
 *
 * The uniform white noise generator is the basis for all colors
 * produced by this struct. It will use the *Ranq1* code recommended
 * by the book "Numerical Recipes" by Press et al. p. 351. It is a
 * composed generator capable of producing random numbers (the
 * std::rand() function produces slightly correlated output) and has a
 * period of \e only 1.8 * 10^19. But for our use at hand it is more
 * than sufficient.
 *
 * @return A 64 bit integer uniformly and independently distributed
 * random number.
 */
unsigned long long int Randomizer::white_uniform_int64(){
	uniformStateInt64 ^= uniformStateInt64 >> 21;
	uniformStateInt64 ^= uniformStateInt64 << 35;
	uniformStateInt64 ^= uniformStateInt64 >> 4;
	return uniformStateInt64 * 2685821657736338717LL;
}
/**
 * @brief Uniform white noise generator at double precision.
 *
 * @return A double precision uniformly and independently
 * distributed random number.
 */
double Randomizer::white_uniform(){
	return 5.42101086242752217E-20 * white_uniform_int64();
}
//////////////////////////////////////////////////////////////////////

////////////////////////// Gaussian white noise //////////////////////
/**
 * @brief Gaussian white noise generator at double precision.
 *
 * This function is based on the Box-Muller transformation. The
 * resulting Gaussian random variable will be of mean 0 and of
 * standard deviation \p standardDeviation.
 *
 * While other algorithms do approximate the Gaussian nature of the
 * generated noise this one will yield the most precise results
 * because it is based on more mathematical exact transformation.
 *
 * @param standardDeviation A double precision number specifying the
 * standard deviation, or square root of the variance, of the
 * generated Gaussian white noise.
 *
 * @sa white_uniform
 *
 * @return A double precision independently and normally distributed
 * random number.
 */
double Randomizer::white_gaussian( double standardDeviation ){
	double uniformRandomNumber1, uniformRandomNumber2,
		distance, factor;
	// Check, whether there is still a Gaussian random variable
	// left from the previous call.
	if ( gaussianSecondVariable == .0 ){
		do {
			uniformRandomNumber1 = 2.0 *
				white_uniform() - 1.0;
			uniformRandomNumber2 = 2.0 *
				white_uniform() - 1.0;
			// For this transformation to work the
			// resulting point (if both numbers are
			// assumed to be positions along two
			// orthogonal axes) has to be in the unit
			// cycle.
			distance = uniformRandomNumber1 *
				uniformRandomNumber1 +
				uniformRandomNumber2 *
				uniformRandomNumber2;
		} while ( distance >= 1.0 || distance == 0 );
		factor = sqrt( -2.0 * log( distance )/ distance );
		gaussianSecondVariable =
			uniformRandomNumber1 * factor;
		return standardDeviation *
			uniformRandomNumber2 * factor;
	} else {
		// Use the stored number from the previous call
		// instead.  
		factor = gaussianSecondVariable;
		gaussianSecondVariable = 0.;
		return factor * standardDeviation;
	}
}
//////////////////////////////////////////////////////////////////////
	
/////////////////////////////// Pink noise ///////////////////////////
/**
 * @brief Pink noise generator at double precision.
 *
 * The one over frequency behavior of a true pink spectrum will be
 * approximated by summing a bunch of white noises, which are updated
 * on different time scales. Those times are positioned equidistant on
 * a logarithmic time scale. This algorithm will generate a fair 1/f
 * spectrum with some inaccuracy at very low frequencies and is based
 * on code snippet posted by Phil Burk on the music-dsp mailing
 * list. http:www.firstpr.com.au/dsp/pink-noise/ The number of
 * involved independent random white noises can be controlled using
 * the \p PINK_USED_ROWS constant in the corresponding header file.
 *
 * @param scale A float number, which will be multiplied with the
 * resulting pink random numbers.
 *
 * @sa white_uniform_int64
 *
 * @return A pink random number at float precision
 */
float Randomizer::pink( float scale ){
	long uniformRandomNumber, sumUpdate;
	float output;
	// Increment the index and assure it is compatible with its
	// mask. 
	indexPink = ( indexPink + 1 ) & indexMaskPink;
	// If index is zero, don't update any random values.
	if( indexPink != 0 ){
		// Determine the number of trailing zeros in
		// `indexPink'. This is done by shifting `indexPink'
		// to the right until the leftmost bit is a zero. The
		// algorithm will hang if `indexPink' is zero.
		int numberOfZeros = 0;
		int nn = indexPink;
		while( ( nn & 1 ) == 0 ){
			nn = nn >> 1;
			numberOfZeros++;
		}
		// The number of trailing zeros will now be used to
		// determine the white noise source, which will be
		// replaced. This way the first one will be updated
		// every 2^1 times, the second one every 2^2 times and
		// so on. This they all life of different time scales
		// with an equal distance in logarithmic time.
		//
		// To speed up the algorithm the sum over all white
		// noise sources will not be calculated in every
		// run. Instead, the chosen one will be subtracted and
		// the updated value will be add back to
		// `runningSumPink'.
		runningSumPink -= rowsPink[ numberOfZeros ];
		uniformRandomNumber =
			( (long)white_uniform_int64() ) >> PINK_SHIFT;
		runningSumPink += uniformRandomNumber;
		rowsPink[ numberOfZeros ] = uniformRandomNumber;
	}
	// An extra white noise source will be added in every step. It
	// will thus live on a time scale of 2^0. Discard the first
	// `PINK_SHIFT' bits to reduce the generated random number to
	// the size of `PINK_BITS' bits.
	uniformRandomNumber =
		( (long)white_uniform_int64() ) >> PINK_SHIFT;
	sumUpdate = runningSumPink + uniformRandomNumber;
	// Scale the result to a range from -1.0 to 0.9999.
	output = normalizationPink * sumUpdate;
	return output * scale;
}
//////////////////////////////////////////////////////////////////////

};
